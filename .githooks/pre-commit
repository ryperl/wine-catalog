#!/bin/bash

# Git pre-commit hook to prevent secrets from being committed
# This hook scans staged files for potential secrets and sensitive information

set -e

echo "üîí Running pre-commit security check..."

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Flag to track if any secrets are found
SECRETS_FOUND=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo "üìù No staged files to check"
    exit 0
fi

echo "üìã Checking staged files for secrets..."

# Function to check for secrets in a file
check_file_for_secrets() {
    local file="$1"
    local issues_found=0
    
    # Skip binary files
    if file "$file" | grep -q "binary"; then
        return 0
    fi
    
    # Skip the pre-commit hook itself (contains regex patterns that look like secrets)
    if [[ "$file" == *"pre-commit"* ]] || [[ "$file" == *".githooks"* ]]; then
        return 0
    fi
    
    # Skip files that are too large (>1MB)
    if [ -f "$file" ] && [ $(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0) -gt 1048576 ]; then
        echo "‚ö†Ô∏è  Skipping large file: $file"
        return 0
    fi
    
    echo "   Checking: $file"
    
    # Define patterns to check for
    declare -a PATTERNS=(
        # API Keys and Tokens
        "api[_-]?key[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
        "api[_-]?secret[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
        "access[_-]?token[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
        "auth[_-]?token[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
        
        # Database URLs with passwords
        "mongodb://[^:]+:[^@\$]+@"
        "mysql://[^:]+:[^@\$]+@"
        "postgres://[^:]+:[^@\$]+@"
        
        # JWT Secrets (but exclude example patterns)
        "jwt[_-]?secret[[:space:]]*[:=][[:space:]]*['\"][^'\"]{20,}['\"]"
        
        # Private Keys
        "-----BEGIN [A-Z ]*PRIVATE KEY-----"
        "-----BEGIN RSA PRIVATE KEY-----"
        "-----BEGIN DSA PRIVATE KEY-----"
        "-----BEGIN EC PRIVATE KEY-----"
        
        # Common password patterns (but exclude obvious placeholders)
        "password[[:space:]]*[:=][[:space:]]*['\"][^'\"]{8,}['\"]"
        
        # AWS Keys
        "AKIA[0-9A-Z]{16}"
        "aws[_-]?secret[_-]?access[_-]?key"
        
        # Google Cloud
        "AIza[0-9A-Za-z\\-_]{35}"
        
        # Generic secrets
        "secret[_-]?key[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
        "client[_-]?secret[[:space:]]*[:=][[:space:]]*['\"][a-zA-Z0-9_-]{16,}['\"]"
    )
    
    # Define patterns that should be ignored (common false positives)
    declare -a IGNORE_PATTERNS=(
        "password.*example"
        "password.*placeholder"
        "password.*your[_-]password"
        "password.*test[_-]password"
        "password.*defaultpassword"
        "password.*change[_-]me"
        "password.*YOUR_"
        "jwt.*YOUR_"
        "secret.*YOUR_"
        "secret.*example"
        "secret.*placeholder"
        "secret.*change[_-]me"
        "secret.*MINIMUM_32_CHARACTERS"
        "mongodb://.*YOUR_"
        "mongodb://.*\$\{.*\}"
        "api.*YOUR_"
        "\$\{[^}]+\}"
    )
    
    # Check each pattern
    for pattern in "${PATTERNS[@]}"; do
        if grep -i -E "$pattern" "$file" > /dev/null 2>&1; then
            # Check if it matches any ignore pattern
            local should_ignore=0
            local match_line=$(grep -i -E "$pattern" "$file" | head -1)
            
            for ignore_pattern in "${IGNORE_PATTERNS[@]}"; do
                if echo "$match_line" | grep -i -E "$ignore_pattern" > /dev/null 2>&1; then
                    should_ignore=1
                    break
                fi
            done
            
            if [ $should_ignore -eq 0 ]; then
                echo -e "   ${RED}‚ùå Potential secret found in $file:${NC}"
                grep -i -n -E "$pattern" "$file" | head -3 | sed 's/^/      /'
                echo ""
                issues_found=1
            fi
        fi
    done
    
    # Check for specific high-risk file patterns
    case "$file" in
        *.env|*.env.*)
            if [[ ! "$file" =~ \.env\.example$ ]] && [[ ! "$file" =~ \.env\.template$ ]]; then
                echo -e "   ${RED}‚ùå Environment file should not be committed: $file${NC}"
                issues_found=1
            fi
            ;;
        *.key|*.pem|*.p12|*.pfx)
            echo -e "   ${RED}‚ùå Private key file should not be committed: $file${NC}"
            issues_found=1
            ;;
        *credentials*|*secrets*)
            if [[ ! "$file" =~ \.(md|txt|example)$ ]]; then
                echo -e "   ${YELLOW}‚ö†Ô∏è  Potential credentials file: $file${NC}"
                echo "      Please review this file carefully"
            fi
            ;;
    esac
    
    return $issues_found
}

# Check each staged file
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        if ! check_file_for_secrets "$file"; then
            SECRETS_FOUND=1
        fi
    fi
done

# Final result
if [ $SECRETS_FOUND -eq 1 ]; then
    echo ""
    echo -e "${RED}üö® COMMIT BLOCKED: Potential secrets detected!${NC}"
    echo ""
    echo -e "${YELLOW}To fix this:${NC}"
    echo "1. Remove or replace the detected secrets with placeholders"
    echo "2. Add sensitive files to .gitignore"
    echo "3. Use environment variables or .env.example templates"
    echo "4. If this is a false positive, you can bypass with: git commit --no-verify"
    echo ""
    echo -e "${YELLOW}Security reminder:${NC}"
    echo "- Never commit real passwords, API keys, or private keys"
    echo "- Use .env files for local secrets (already in .gitignore)"
    echo "- Use placeholder values in documentation and examples"
    echo ""
    exit 1
else
    echo -e "${GREEN}‚úÖ Security check passed - no secrets detected${NC}"
    exit 0
fi
